<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Reflection</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Portfolio Reflection</h1>
    </header>
    <main>
        <section>
            <h2>1. How do you determine the most efficient approach when solving a complex problem?</h2>
            <p>To determine the most efficient approach, I:</p>
            <ul>
                <li><strong>Analyze the Problem:</strong> Break it down to understand its constraints, input size, and expected output.</li>
                <li><strong>Evaluate Algorithmic Options:</strong> Compare possible solutions based on their time and space complexities.</li>
                <li><strong>Consider Constraints:</strong> For example, if real-time processing is required, prioritize time efficiency over space.</li>
                <li><strong>Test Feasibility:</strong> Use sample inputs to ensure the algorithm handles edge cases effectively.</li>
            </ul>
        </section>

        <section>
            <h2>2. What criteria do you use to evaluate the effectiveness of a solution?</h2>
            <ul>
                <li><strong>Efficiency:</strong> Does the solution run within acceptable time and space limits?</li>
                <li><strong>Scalability:</strong> Can it handle large datasets or increased input sizes?</li>
                <li><strong>Robustness:</strong> Does it work correctly across all edge cases?</li>
                <li><strong>Maintainability:</strong> Is the code readable and easy to modify for future requirements?</li>
                <li><strong>Simplicity:</strong> Avoid unnecessary complexity while meeting requirements.</li>
            </ul>
        </section>

        <section>
            <h2>3. Reflect on a situation where you need to balance multiple conflicting constraints in a design. What approach did you take?</h2>
            <p><strong>Example:</strong> Designing an algorithm for a real-time train scheduling system.</p>
            <ul>
                <li><strong>Conflicting Constraints:</strong> Real-time responsiveness (time efficiency) vs. accurate predictions based on large datasets (space efficiency).</li>
                <li><strong>Approach:</strong>
                    <ul>
                        <li>Used <em>greedy algorithms</em> for quick decisions on immediate scheduling.</li>
                        <li>Employed <em>dynamic programming</em> for long-term optimizations, running in the background.</li>
                        <li>Cached intermediate results to reduce redundant calculations.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h2>4. How do you decide when to prioritize simplicity over optimization in a solution?</h2>
            <ul>
                <li><strong>Problem Context:</strong> If the problem is well-defined, small-scale, or needs rapid prototyping, simplicity is prioritized.</li>
                <li><strong>Resource Constraints:</strong> Limited time or computational resources favor simple solutions.</li>
                <li><strong>Future Scope:</strong> If a solution is likely to evolve, simplicity ensures maintainability.</li>
            </ul>
            <p><strong>Example:</strong> For a classroom project, I prioritize simplicity to ensure the solution is understandable and meets learning objectives.</p>
        </section>

        <section>
            <h2>5. Reflect on how breaking down a problem into smaller components can help you approach it more effectively.</h2>
            <p><strong>Example:</strong> Implementing a dynamic programming solution for the Knapsack problem.</p>
            <ul>
                <li><strong>Breaking Down:</strong>
                    <ul>
                        <li>Divided the problem into subproblems (smaller weight capacities and items).</li>
                        <li>Solved each subproblem iteratively and used the results to build the final solution.</li>
                    </ul>
                </li>
                <li><strong>Benefits:</strong> Simplifies debugging, improves clarity, and helps identify patterns in the problem.</li>
            </ul>
        </section>

        <section>
            <h2>6. Reflect on the trade-offs while choosing between different approaches to solve a problem.</h2>
            <p><strong>Example:</strong> Choosing between Merge Sort and Quick Sort.</p>
            <ul>
                <li><strong>Trade-Offs:</strong>
                    <ul>
                        <li>Merge Sort is stable and predictable (
(O(n log n)) but uses more space (
O(n)).</li>
                        <li>Quick Sort is faster on average but has a worst-case time complexity of (
O(n
2)).</li>
                    </ul>
                </li>
                <li><strong>Decision:</strong> For large datasets where stability matters, I choose Merge Sort; for in-memory operations with small datasets, Quick Sort is preferable.</li>
            </ul>
        </section>

        <section>
            <h2>7. How do you identify and address potential limitations or weaknesses in a proposed solution?</h2>
            <ul>
                <li><strong>Stress Testing:</strong> Run the solution on edge cases and large datasets to identify weaknesses.</li>
                <li><strong>Performance Profiling:</strong> Measure time and space usage to detect bottlenecks.</li>
                <li><strong>Feedback:</strong> Seek peer reviews to catch overlooked issues.</li>
                <li><strong>Refinement:</strong> Optimize code sections with the highest impact, such as reducing redundant operations.</li>
            </ul>
        </section>

        <section>
            <h2>8. How do you decide when to innovate versus relying on tried-and-tested solutions?</h2>
            <ul>
                <li><strong>Problem Novelty:</strong> If a problem aligns closely with existing solutions, I start with tried-and-tested methods.</li>
                <li><strong>Opportunity for Improvement:</strong> If existing methods fall short in efficiency or scalability, I innovate by adapting or creating new solutions.</li>
            </ul>
            <p><strong>Example:</strong> For navigating train overcrowding, I innovated by integrating real-time passenger density data into Dijkstraâ€™s algorithm.</p>
        </section>
    </main>
</body>
</html>
